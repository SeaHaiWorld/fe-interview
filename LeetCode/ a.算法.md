# 算法题

- 1.包含min函数的栈
  - 辅助栈，要求时间复杂度O(1)
- 2.用两个栈实现队列
  - 反转数组
- 3.从尾到头打印链表
  - 反转数组
- 4.反转链表
  - 反转后初始为null
  - 避免 cycle ListNode
- 5.复制复杂链表
  - 题目是想让我们深度拷贝，如果是普通链表的话，顺序遍历来创建新的节点就行；
  - 但是本题的难点在于随机指针的存在，当我们拷贝节点时，「当前节点的随机指针指向的节点」可能还没创建
  - 解题方法1，map存储：
    - 先从头节点顺序遍历链表直至链尾，把每个遍历到的节点都存储到map中
    - 再从头节点顺序遍历，更新map中对应节点的next指针和random指针
    - 返回map中的头节点，也就是复制后的头节点
- 6.替换空格
  - 正则 + replaceAll
  - 栈
  - 原地替换
- 7.左旋转字符串
  - slice 方法
  - 栈
  - 排序
  - 递归
- 8.二分查找
- 9.二维数组中的查找
  - 二分查找
  - 标志数转树的遍历
- 10.旋转数组的最小字母
  - 二分查找
  - 找到旋转结点
- 11.从上到下打印二叉树(i) - 同一层的节点按从左到右
  - 二叉树的广度优先搜索（BFS）
- 12.从上到下打印二叉树(ii) - 同一层的节点按从左到右 - 分层打印
  - 二叉树的广度优先搜索（BFS）
- 13.从上到下打印二叉树(iii) - Z 字型打印
  - 第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印等
- 14.树的子结构
  - dfs(深度优先搜索) + 辅助函数
- 15.树的镜像
  - dfs + 交换左右结点
- 16.判断对称二叉树
- 17.斐波那契数列
  - 状态转移方程
  - 穷举
    - 循环
    - 递归
- 18.青蛙跳台阶问题
  - 状态转移方程
  - 穷举
    - 循环
    - 递归
- 19.股票的最大利润
  - 暴力枚举
  - 动态规划
    - 找最小值转折点
      - 最低值
      - 一次循环
- 20.连续子数组的最大和
  - 动态规划
- 21.礼物的最大价值
  - 动态规划
  - 走格子
- 22.把数字翻译成字符串
  - 动态规划
- 23.删除链表的节点
  - 递归
    - 边界条件，跳过对应结点。实现链表的联结
  - 双指针
- 24.链表中倒数第 k 个节点
  - 第一时间想到的解法
    - 先遍历统计链表长度，记为 n
    - 设置一个指针走 (n-k) 步，即可找到链表倒数第 k 个节点
  - 双指针法：不需要知道链表长度
    - 指针1先走k-1步
    - 然后指针2和指针1同时前进，当指针1指向链表最后一个元素时，指针2即为所求
- 25.合并两个排序的链表
  - 双指针
    - 快慢指针
    - 虚拟结点
- 26.警告一小时内使用相同员工卡大于等于三次的人
  - 哈希表 + 排序
  - 优化
    - map迭代
    - unicode字符码计算
- 27.删除子文件夹
  - 排序 + 入栈
- 28.困于环中的机器人
  - 模拟
- 29.段式回文
  - 双指针
- 30.驼峰式匹配
  - 双指针
- 31.节点与其祖先之间的最大差值
  - dfs 深度优先遍历
- 32.分隔数组以得到最大和
  - 动态规划
- 33.填充书架
  - 动态规划
- 34.摘水果
  - 滑动窗口
- 35.非重叠子数组的最大和
  - 滑动窗口
- 36.数组扁平化
  - 递归
- 37.myEvents实现
- 38.闭包陷阱
- 39.全排列
  - 回溯算法 + 递归
- 40.将数组中的元素向右移动 k 个位置
- 41.实现myPromise
- 42.实现promisify
- 43.实现深拷贝
- 44.实现call或apply
- 45.非递减数列
- 46.最长不含重复字符的子字符串
- 47.compose
- 48.实现节流防抖
- 49.找出缺失和重复的数字
  - 用一个 Set 来追踪已经出现过的数字，这样你就可以在 O(1) 时间内检查一个数字是否已经出现过，而不必每次都遍历 stack 数组。
- 50.从链表中移除节点
  - 递归
  - 栈
  - 反转链表
- 51.给小朋友们分糖果 I
- 52.分糖果
- 53.合并两个有序的数组
- 54.移除元素
